1
00:00:00,000 --> 00:00:08,500
这次我们认识下HANA服务器端的JavaScript（xsjs）

2
00:00:09,000 --> 00:00:16,475
在SP05中，XSJS主要用来显示HANA中的数据

3
00:00:16,486 --> 00:00:21,490
到外部系统或者用户界面上

4
00:00:21,596 --> 00:00:28,511
SP05中，XSJS的主要用于在HANA中处理数据

5
00:00:28,455 --> 00:00:38,173
还有如并行更新计算和逻辑控制等功能

6
00:00:38,256 --> 00:00:48,753
 SP06提供了HTTP出站请求新功能

7
00:00:48,790 --> 00:00:52,833
这个特性将HANA变成一个“数据消费者”

8
00:00:52,790 --> 00:00:59,386
使我们可以调用并获取其他系统的数据

9
00:00:59,387 --> 00:01:05,703
这种机制用来捕获数据并保存在HANA数据库中

10
00:01:05,713 --> 00:01:15,819
在某种程度上利用外部服务等创建混合网站，

11
00:01:15,887 --> 00:01:20,186
来提供查找，验证数据等服务。

12
00:01:20,185 --> 00:01:25,413
也可以很方便地使用它来调用ABAP应用系统

13
00:01:25,437 --> 00:01:35,216
消费ABAP或JAVA应用中的数据并存到HANA中

14
00:01:35,250 --> 00:01:37,507
我想给你们展示两个应用场景

15
00:01:37,536 --> 00:01:44,903
第一个是在ABAP上创建一个简单RESTFulf服务来暴露数据

16
00:01:44,978 --> 00:01:51,241
然后用XSJS调用Web服务并保存数据到HANA数据库中

17
00:01:51,483 --> 00:01:55,205
第二个例子展示混搭应用

18
00:01:55,210 --> 00:02:01,534
使用简单免费的"国会图片检索"web服务

19
00:02:01,500 --> 00:02:07,654
我将会给你展示如何使用HANA访问这上面的数据

20
00:02:07,701 --> 00:02:16,001
通过检索并将HANA中数据和图片一并显示在页面上

21
00:02:19,943 --> 00:02:29,303
第一个要演示是从ABAP中消费数据

22
00:02:29,311 --> 00:02:40,251
为了展示我用无状态的BSP在ABAP中创建一个简单的web服务

23
00:02:40,282 --> 00:02:54,645
这是个好且简单地创建web服务的方式。。。来看下它的逻辑。。

24
00:02:54,727 --> 00:03:04,952
用OnInitialization方法

25
00:03:04,976 --> 00:03:10,983
创建了一个基于JSON的Writer对象

26
00:03:11,050 --> 00:03:16,845
还创建了一个小的类zcl_user包含方法get_details

27
00:03:16,864 --> 00:03:23,217
它接受username为输入参数

28
00:03:23,470 --> 00:03:31,725
用username查找用户详细信息并返回用户地址

29
00:03:32,225 --> 00:03:40,687
get_details只是用调用BAPI来获取用户数据并返回地址

30
00:03:40,713 --> 00:03:51,481
如果有错误就在BAPI里抛出详细异常信息

31
00:03:51,757 --> 00:04:01,832
然后我只是把ABAP地址格式转换成JSON格式

32
00:04:01,950 --> 00:04:11,549
默认情况下，转换是输入二进制格式

33
00:04:11,536 --> 00:04:18,852
通过Writer对象转换成文本格式

34
00:04:18,882 --> 00:04:23,964
lv_json就是字符串类型的

35
00:04:23,998 --> 00:04:29,857
这样就输出了JSON字符串

36
00:04:29,873 --> 00:04:36,875
如果有错误发生，将返回的对象也转换成JSON格式

37
00:04:36,906 --> 00:04:44,012
并设置HTTP状态码为500，返回错误消息

38
00:04:44,042 --> 00:04:48,673
如果你谙熟ABAP，你可能已经嗅到了不一样

39
00:04:48,637 --> 00:04:52,612
那是因为我用的是ABAP 740的版本

40
00:04:52,581 --> 00:05:03,242
隐式类型定义，可以直接转换或返回为左边定义的类型

41
00:05:03,269 --> 00:05:09,965
#符号通过下标来访问内部表中的记录

42
00:05:09,997 --> 00:05:15,892
看不懂的话也不要迷茫

43
00:05:15,872 --> 00:05:19,041
这些只是ABAP 740中新的，好的语法而已

44
00:05:19,058 --> 00:05:25,378
这些新语法并不是这次视频的目的，ABAP仅是作为例子

45
00:05:25,351 --> 00:05:31,653
来创建web服务，并且被HANA调用

46
00:05:31,689 --> 00:05:35,907
棒极了

47
00:05:35,926 --> 00:05:39,603
为了测试让我在浏览器中打开

48
00:05:47,275 --> 00:06:02,829
复制粘贴web服务地址到浏览器中

49
00:06:03,329 --> 00:06:10,784
加上username

50
00:06:11,284 --> 00:06:15,631
username=jungth

51
00:06:16,131 --> 00:06:26,603
返回了JSON格式数据，包含了用户的详细信息

52
00:06:27,103 --> 00:06:39,893
web服务建好了，下面让我们在HANA中来轻松地访问这些数据

53
00:06:40,393 --> 00:06:53,097
如果你看过CDS这个视频，那里我创建了一个用户表

54
00:06:53,103 --> 00:07:00,783
让我们快速的回顾下这张表

55
00:07:01,283 --> 00:07:05,635
表包含PERS_NO, FIRSTNAME, LASTNAME 和EMAIL字段

56
00:07:05,649 --> 00:07:13,235
这些字段正是我们从ABAP web服务中拉过来的

57
00:07:13,277 --> 00:07:17,767
而且表里也没有数据。

58
00:07:17,827 --> 00:07:21,711
现在让我们写一个小的JS脚本

59
00:07:21,732 --> 00:07:28,377
脚本执行会从ABAP系统中查询并拉取用户详细信息

60
00:07:28,380 --> 00:07:33,630
并保存到HANA数据库中的User表里

61
00:07:33,746 --> 00:07:39,608
我应该提示下这个HANA系统，

62
00:07:39,783 --> 00:07:46,073
为了这个演示，我的说它和ABAP系统没有关系

63
00:07:46,147 --> 00:07:51,682
虽然理论上ABAP是运行在HANA数据库上的

64
00:07:51,711 --> 00:07:55,443
为了演示，我们的假设ABAP和HANA是两个独立的系统

65
00:07:55,455 --> 00:07:57,903
HANA可以作为独立的系统存在（数据库+系统）

66
00:07:57,939 --> 00:08:04,878
我们通过SLT，BOBJ把数据从ABAP上移到HANA数据库中

67
00:08:04,904 --> 00:08:14,731
然而通过另外一种方式，你甚至可以调用BAdI，更新ABAP系统上的数据

68
00:08:14,725 --> 00:08:18,753
还有更多的可能性，比如访问ABAP系统中业务逻辑等

69
00:08:18,740 --> 00:08:24,086
这里我们故意简化这个例子来达到学习的目的

70
00:08:24,586 --> 00:08:29,184
在我调用web服务之前

71
00:08:29,223 --> 00:08:38,262
我需要一个新的对象来定义ABAP上web服务目标

72
00:08:38,388 --> 00:08:44,289
现在创建一个后缀为xshttpdest的文件

73
00:08:44,404 --> 00:08:49,447
打开service文件夹，创建新文件

74
00:08:49,497 --> 00:08:58,784
文件名为 user.xshttpdest

75
00:08:59,284 --> 00:09:07,841
为了演示，我已经准备好了，你也不想看我码字，我们来看内容

76
00:09:07,959 --> 00:09:12,868
基本上你需要提供主机host

77
00:09:12,887 --> 00:09:19,490
端口号port来建立http连接

78
00:09:19,625 --> 00:09:23,788
目标连接的描述description

79
00:09:23,801 --> 00:09:29,589
路径前缀pathPrefix

80
00:09:29,646 --> 00:09:33,382
pathPrefix上甚至包含了输入的参数username

81
00:09:33,424 --> 00:09:40,380
我可以在代码中提供pathPrefix之后的所有内容

82
00:09:40,482 --> 00:09:45,289
我只是想简化例子，它需要做的就是解析username的值

83
00:09:45,541 --> 00:09:51,385
如果有多个参数的话，我就不会这个干了

84
00:09:51,585 --> 00:09:54,616
在后面的代码里你会看到

85
00:09:55,116 --> 00:09:57,663
指定身份验证类型的authType

86
00:09:57,692 --> 00:10:00,985
这个例子里web服务不需要用户验证

87
00:10:01,008 --> 00:10:04,393
也许不是个现实的场景

88
00:10:04,421 --> 00:10:14,474
尤其是关于用户信息的web服务，但是作为例子却能很容易地展示

89
00:10:14,480 --> 00:10:20,013
我可以用BASIC验证方式弹出用户登陆框

90
00:10:20,114 --> 00:10:26,605
在xhttpdest中也可以很容易的维护用户名和密码来验证

91
00:10:26,918 --> 00:10:34,757
但为了简化这个例子，这里没有用户验证

92
00:10:34,914 --> 00:10:42,208
这个例子也没有用到Proxy因为ABAP系统在同一个防火墙内

93
00:10:42,365 --> 00:10:49,726
保存xshttpdest并激活

94
00:10:49,877 --> 00:10:59,287
我可以用快捷键或者工具栏上的激活按钮来激活

95
00:10:59,324 --> 00:11:03,506
但我已经习惯了右击菜单来激活

96
00:11:03,635 --> 00:11:09,044
下一步就是在代码中用这个xshttpdest文件

97
00:11:09,008 --> 00:11:19,593
让我来创建一个新服务，取名为User.xsjs

98
00:11:19,810 --> 00:11:28,544
复制粘贴，你应该不想看我敲代码

99
00:11:28,572 --> 00:11:30,572
我们来过一遍

100
00:11:30,695 --> 00:11:37,637
首先执行很简单，没有任何参数输入

101
00:11:37,610 --> 00:11:45,922
我可以检查一下用户名是否合法，但作为例子，还是简单点好

102
00:11:45,895 --> 00:11:54,971
进入方法内，用httprequest对象来获取username

103
00:11:54,994 --> 00:12:03,774
你总得解析username并获取到那个用户的信息

104
00:12:03,779 --> 00:12:12,658
在真实场景中，我可能先获取到所有的用户

105
00:12:12,646 --> 00:12:15,176
然后从ABAP循环请求每一个用户详细信息

106
00:12:15,166 --> 00:12:18,196
但作为例子，我们保持简单(KISS)

107
00:12:18,220 --> 00:12:21,956
下一步创建一个http destination对象

108
00:12:21,967 --> 00:12:30,570
用新的API,$.net.http.readDestination

109
00:12:30,552 --> 00:12:37,333
把xshttpdest路径传给方法

110
00:12:37,349 --> 00:12:43,020
改为我的仓库路径sp06.services

111
00:12:42,995 --> 00:12:50,429
xshttpdest的名字是user作为第二个参数

112
00:12:50,439 --> 00:12:57,147
创建Http Client和WebRequest实例并调用

113
00:12:57,130 --> 00:12:59,886
Http Method是GET

114
00:12:59,895 --> 00:13:14,353
唯一的参数是username字符串

115
00:13:14,410 --> 00:13:22,507
还记得我在path中设置username=

116
00:13:22,512 --> 00:13:28,366
所以这里是直接把username附加到路径上

117
00:13:28,483 --> 00:13:36,493
req和dest作为参数调用client.request方法，得到响应

118
00:13:36,823 --> 00:13:45,348
这里我们拿到响应主体中的数据

119
00:13:45,372 --> 00:13:49,759
查看请求响应状态

120
00:13:49,744 --> 00:13:58,921
把我们这个服务的响应状态设置为当前请求的响应状态

121
00:13:59,016 --> 00:14:05,410
这里也检查状态，如果有服务异常

122
00:14:05,435 --> 00:14:11,208
拿到异常详细信息并解析为JSON对象

123
00:14:11,228 --> 00:14:14,092
因为ABAP返回的是JSON字符串

124
00:14:14,111 --> 00:14:22,161
所以很容易被JSON.parse解析成JS对象

125
00:14:22,141 --> 00:14:25,617
response.setBody设置响应内容

126
00:14:25,633 --> 00:14:33,266
我可以用JS下标访问ABAP内部表ITAB

127
00:14:33,240 --> 00:14:40,193
取到下标为0的MESSAGE字段并输出

128
00:14:40,167 --> 00:14:48,738
JSON(其实是JS)非常容易的访问嵌套结构的对象

129
00:14:48,699 --> 00:14:57,232
ABAP结构或内部表转换成JSON字符串就很容易被XSJS访问

130
00:14:57,244 --> 00:15:05,372
如果ABAP服务没有异常发生

131
00:15:05,421 --> 00:15:10,000
当然现实中要检查服务异常，不过作为例子(KISS)

132
00:15:09,987 --> 00:15:20,353
然后解析响应主体，并保存到数据库，设置响应主体消息

133
00:15:20,388 --> 00:15:23,911
一条消息称用户xxx已被保存

134
00:15:23,917 --> 00:15:31,478
这里没啥新内容，语法和sp05一样

135
00:15:31,482 --> 00:15:38,203
我只是建立了一个Query对象，UPSET语句来保存到数据库

136
00:15:38,207 --> 00:15:48,247


137
00:15:48,747 --> 00:15:55,817
这里用了预编译语句以防止SQL注入

138
00:15:55,876 --> 00:15:59,009
因为这里数据来自外部，但我信任这些数据

139
00:15:59,017 --> 00:16:07,932
我可以用userDet来访问ABAP服务返回的用户数据

140
00:16:07,930 --> 00:16:11,999
最后保存到数据库中

141
00:16:11,976 --> 00:16:20,119
因为用的是UPSET语句，故不存在时保存，存在时更新

142
00:16:20,095 --> 00:16:28,021
万事俱备了

143
00:16:28,020 --> 00:16:30,020
激活

144
00:16:30,520 --> 00:16:38,328
现在可以来测试一下服务

145
00:16:38,271 --> 00:16:52,424
打开游览器，输入正确的地址

146
00:16:52,468 --> 00:17:01,123
加上URL参数username=GUNGTH

147
00:17:01,376 --> 00:17:03,376
验证用户

148
00:17:03,482 --> 00:17:08,305
成功显示响应信息“用户xxx已经被保存”

149
00:17:08,435 --> 00:17:22,101
如果想验证数据是否保存，可以去表中直接查看

150
00:17:22,224 --> 00:17:35,360
同样的，再测试另一个，成功保存

151
00:17:35,553 --> 00:17:39,931
最后如果输入非法的用户名JUNK

152
00:17:39,940 --> 00:17:47,797
得到消息说：JUNK不存在

153
00:17:47,792 --> 00:17:52,611
简单的例子阐释了一个系统集成的场景

154
00:17:52,583 --> 00:18:00,954
XSJS不仅可以暴露数据，也可以调用其他服务来获取数据

155
00:18:05,586 --> 00:18:07,680
再来一个例子

156
00:18:07,700 --> 00:18:14,236
这次我要调用的是一个完全外部服务

157
00:18:14,248 --> 00:18:20,725
国会图片检索（Congress Image Search）

158
00:18:20,786 --> 00:18:26,670
再来创建一个xshttpdest文件

159
00:18:27,170 --> 00:18:35,783
取名image.xshttpdest

160
00:18:36,283 --> 00:18:46,954
设置host为www.loc.gov，端口为80

161
00:18:46,991 --> 00:18:54,580
pathPrefix已经设置成输出为JSON格式

162
00:18:54,667 --> 00:19:03,096
你也可以看到我设置了query参数q=

163
00:19:03,263 --> 00:19:05,992
这个例子也没有验证

164
00:19:06,071 --> 00:19:17,354
但服务器不在SAP防火墙内，所以设置了代理服务器

165
00:19:17,386 --> 00:19:24,380
这就是xshttpdest文件

166
00:19:24,400 --> 00:19:35,427
现在创建一个XSJS文件Images.xsjs

167
00:19:35,328 --> 00:19:45,421
复制粘贴代码，searchImages方法需要两个URL参数

168
00:19:45,648 --> 00:19:58,940
一个需要在图片库中检索的关键字

169
00:19:58,987 --> 00:20:09,418
另一个是索引，因为返回的JSON会包含多个图片

170
00:20:09,430 --> 00:20:14,029
而我只想显示某个图片

171
00:20:14,102 --> 00:20:25,911
如果索引没有在URL中定义，则默认显示第一个

172
00:20:25,853 --> 00:20:32,733
创建的xshttpdest就跟以前的一样

173
00:20:32,642 --> 00:20:39,461
sp6.services为路径，images是xshttpdest名字

174
00:20:39,435 --> 00:20:44,781
就像上个例子中建立的查询字符串一样

175
00:20:44,807 --> 00:20:51,723
把req和dest作为参数调用HTTP请求

176
00:20:52,223 --> 00:20:57,498
依然拿到JSON格式的响应主体

177
00:20:57,540 --> 00:21:03,501
首先检查响应状态，如果有错就返回获取到的错误信息

178
00:21:03,543 --> 00:21:11,432
为了演示，解析错误信息并输出没大碍

179
00:21:11,506 --> 00:21:17,491
如果没有错误，我实际上写了一小段HTML来输出

180
00:21:17,477 --> 00:21:26,142
首先解析返回内容，显示目前是第几张图片

181
00:21:26,122 --> 00:21:35,452
然后把返回的图片URL用于img标签中

182
00:21:35,525 --> 00:21:43,945
这儿我能用下标index访问返回解析过的JS对象

183
00:21:43,923 --> 00:21:49,329
.imge.full来访问完整的图片地址

184
00:21:49,293 --> 00:21:57,897
保存这两个文件并激活

185
00:21:58,397 --> 00:22:07,767
现在可以来测试这个服务了

186
00:22:07,789 --> 00:22:18,520
在浏览器中输入正确的地址

187
00:22:19,020 --> 00:22:29,805
用New York作为关键字来查询

188
00:22:30,305 --> 00:22:36,816
一共找到95960条关于New York的图片

189
00:22:36,786 --> 00:22:42,579
现在默认显示的是第一张图片

190
00:22:42,670 --> 00:22:46,863
如果想查看某张特殊的图片

191
00:22:46,984 --> 00:22:53,428
用下标index=3查看第三张图片

192
00:22:53,549 --> 00:22:58,461
额，有意思，来看第6张

193
00:22:58,519 --> 00:23:04,047
当然也能更改查询关键字

194
00:23:04,251 --> 00:23:11,991
我，我，我想看米老鼠。。。

195
00:23:12,491 --> 00:23:15,687
额，第一张竟然没有数字化。。。

196
00:23:15,711 --> 00:23:20,085


197
00:23:20,127 --> 00:23:24,379
我要给我儿子看米老鼠

198
00:23:24,456 --> 00:23:30,407


199
00:23:30,430 --> 00:23:34,768
现在你知道怎样创建一个混搭程序

200
00:23:34,776 --> 00:23:38,023
服务是由Congress维护的，开放的图片库

201
00:23:38,037 --> 00:23:43,083
也可以绑定其他服务到我的应用中

202
00:23:43,087 --> 00:23:49,313
这个例子非常简单，只是获取到图片地址并显示

203
00:23:49,346 --> 00:23:55,839
可以想象，在较大的应用的绑定这个图片检索服务

204
00:23:55,842 --> 00:24:05,006
甚至ebay，Google，或者任意多的，可访问的HTTP服务

205
00:24:05,085 --> 00:24:15,387
创建一个真正混搭应用,混合HANA和互联网数据

206
00:24:15,426 --> 00:24:21,028
也可以执行外部逻辑，由于仅是数据获取和展示

207
00:24:21,017 --> 00:24:24,840
也可以触发或更新另外一个系统上的数据等

208
00:24:25,155 --> 00:24:30,763
HANA和它的核心真正地打开了所有的可能
