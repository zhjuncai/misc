1
00:00:00,000 --> 00:23:07,555
对于SP06

2
00:00:00,500 --> 00:00:02,500
Core Data Service HDBDD

3
00:00:02,000 --> 00:00:10,000
在HANA SP05中，我们引入了通过仓库创建大多数数据库对象的概念

4
00:00:10,500 --> 00:00:14,000
大多数情况下是通过创建一个hdbtable的文件

5
00:00:14,000 --> 00:00:21,000
当这个文件被激活的时候会在指定的数据目录中生成一个表

6
00:00:21,000 --> 00:00:29,500
这样做是为了分离和抽象出创建或更改表结构的SQL

7
00:00:29,500 --> 00:00:36,000
开发人员要做的就是维护这个设计时的表现结构(hdbtable文件)

8
00:00:36,000 --> 00:00:38,500
当文件被激活的时候必要的SQL会被自动创建

9
00:00:39,000 --> 00:00:44,000
当然，HANA也是完全具有执行SQL语句能力的数据库

10
00:00:44,500 --> 00:00:50,500
然而，这样创建仓库对象的做法有额外的能力

11
00:00:50,500 --> 00:00:56,500
它使我们很容易地传输数据库对象而不能重新在目标系统上执行

12
00:00:56,500 --> 00:01:07,000
创建或者更改数据库的SQL语句，仅仅通过传输设计时的表结构

13
00:01:07,000 --> 00:01:12,500
当在目标系统上激活时，必要的SQL语句会生成并被执行

14
00:01:12,500 --> 00:01:19,000
HANA也允许我们在SQL语法上增加可能的东西，例如

15
00:01:19,000 --> 00:01:22,500
多语言，数据表列说明等

16
00:01:23,000 --> 00:01:28,500
SAP最终是把HANA做为一个完整的数据字典

17
00:01:28,500 --> 00:01:32,500
不仅有能力定义表对象

18
00:01:33,000 --> 00:01:36,500
还能定于对象之间的关系

19
00:01:37,000 --> 00:01:46,000
甚至继续抽象出简单的基于SQL的查询语言

20
00:01:46,000 --> 00:01:53,500
允许我们访问对象之间的定义关系

21
00:01:54,000 --> 00:02:04,500
现在首先介绍一下SP06中CDS(Core Data Service)

22
00:02:04,500 --> 00:02:09,000
和新开发工件HDBDD

23
00:02:09,000 --> 00:02:11,500
DD是指数据字典(Data Dictionary)

24
00:02:12,000 --> 00:02:18,000
CDS包含三个主要部分

25
00:02:18,000 --> 00:02:29,500
一个是数据定义语言，非常类似于今天说的hdbtable，hdbstructure等

26
00:02:29,500 --> 00:02:35,500
但是CDS是一个单一的语言和开发对象

27
00:02:36,000 --> 00:02:41,000
能使你在SP06中创建表和数据结构

28
00:02:41,500 --> 00:02:50,500
而且扩展了使用同一种CDS语法定义数据库视图和其他对象的能力

29
00:02:51,000 --> 00:03:00,000
事实上，以后所有的HANA对象设计都要使用CDS语法

30
00:03:00,500 --> 00:03:03,500
CDS也是一种查询语言

31
00:03:03,000 --> 00:03:12,000
故我们可以用CDS来定义对象之间的关联关系

32
00:03:12,500 --> 00:03:17,500
说到查询语言，CDS也仅是结构查询语言(SQL)的扩展

33
00:03:17,500 --> 00:03:29,000
所以我们可以访问这些关系之间的关系，如SaleOrder.Item

34
00:03:29,000 --> 00:03:35,500
在运行时就知道他们之间是一对多的关系，一个SalesOrder有多个Item

35
00:03:35,500 --> 00:03:45,000
复杂内连接在幕后自动生成以简化查询语言`

36
00:03:45,000 --> 00:03:59,500
这样做是为了简化开发人员所写的代码和重用已定义的关系

37
00:04:00,000 --> 00:04:04,000
最后CDS也是一种表达式语言

38
00:04:04,000 --> 00:04:12,500
CDS可以允许我们定义更加复杂的行为和表达式

39
00:04:12,500 --> 00:04:20,000
SP06暂时只支持数据定义语言，还不具备定义对象关联关系能力

40
00:04:20,000 --> 00:04:23,500
不过在不久的将来就会被实现加入

41
00:04:26,000 --> 00:04:34,500
过渡期间使用hdbtable，hdbstructure和新的hdbdd

42
00:04:34,500 --> 00:04:38,000
hdbtable和hdbstructure是完全支持的

43
00:04:38,500 --> 00:04:45,500
我现在给你展示一下新的CDS编辑器长啥样

44
00:04:39,500 --> 00:04:47,500


45
00:04:45,500 --> 00:04:54,500
和作为开发者，定义表，结构以及重用表时的体验

46
00:04:54,500 --> 00:05:07,500
回到SAP HANA Studio中上次视频中用新向导创建的工程中 

47
00:05:07,500 --> 00:05:11,500
创建的xsjsaccess和xsjs文件

48
00:05:11,500 --> 00:05:15,500
我们已经创建了一个SP6Demo Schema

49
00:05:15,500 --> 00:05:26,500
我们可以看到现在其中还没有创建任何表，结构和内容

50
00:05:26,500 --> 00:05:35,000
我们创建一个小且简单，存储用户详细信息的User表，如id

51
00:05:35,000 --> 00:05:41,500
在后面的演示中你可以看到这个User表在SP06中新功能

52
00:05:41,500 --> 00:05:57,500
现在让我们开始在data文件夹中，用向导创建一个DDL Souce File

53
00:05:57,500 --> 00:06:15,500
向导创建了一个文件名是User.hdbdd并打开了CDS编辑器

54
00:06:15,500 --> 00:06:22,500
你应该知道在SP06中CDS编辑器只是一个文本编辑器

55
00:06:25,000 --> 00:06:30,500
并且SP06是具有智能语法高亮

56
00:06:30,000 --> 00:06:41,000
在SP07中，我们打算加入图形模式来定于表和结构

57
00:06:41,000 --> 00:06:47,500
你还可以在图形模式和编辑模式中来回切换

58
00:06:47,500 --> 00:06:57,000
可以看到文件的命名空间是包层级结构

59
00:06:57,000 --> 00:07:03,500
命名空间不需要改动，在CDS中有一个context

60
00:07:03,500 --> 00:07:12,000
context的概念就是我们要生成对象名字的一部分

61
00:07:12,500 --> 00:07:20,000
比如我可以有一个context是SalesOrder包括header和item实体

62
00:07:20,000 --> 00:07:26,500
那么生成的目录就是SalesOrder.Header和SalesOrder.Item

63
00:07:27,000 --> 00:07:38,000
我只想创建一个简单的User表，也许后面我还想创建一个Address表，等等

64
00:07:38,500 --> 00:07:50,500
我现在写一些特别的注释

65
00:07:51,000 --> 00:07:57,000
将会把这个对象创建到sp6demo中

66
00:07:57,500 --> 00:08:06,500
现在让我创建一些可以重用的类型

67
00:08:06,500 --> 00:08:15,000
SString短字符，长度为40

68
00:08:15,000 --> 00:08:22,000
这就是可重用字典的价值所在

69
00:08:22,000 --> 00:08:31,500
简单类型，复杂类型可用在不同的实体中重用

70
00:08:32,000 --> 00:08:40,000
这里我只想演示简单的例子，再创建一个长度为255长字符类型LString

71
00:08:40,000 --> 00:08:59,500
重用类型已经创建好了，现在来创建一个列存储的数据表

72
00:08:59,000 --> 00:09:10,000
数据表在CDS中也是一个实体

73
00:09:10,500 --> 00:09:27,500
现在创建PERS_ID为表的主键，类型是长度为10的字符串

74
00:09:28,000 --> 00:09:43,000
就像你看到到，我不能在Entity里面创建重用类型

75
00:09:43,000 --> 00:10:03,000
在创建first_name, last_name两列类型为SString, email列类型为LString

76
00:10:03,000 --> 00:10:13,000
保存并激活hdbdd文件

77
00:10:13,000 --> 00:10:23,500
激活成功后，回到SP6Demo目录中

78
00:10:23,500 --> 00:10:39,000
表sp6.data::User.Detail生成了，包名就是命名空间

79
00:10:39,500 --> 00:10:41,500
::是命名空间分隔符，User.Datail是表名

80
00:10:42,000 --> 00:10:53,000
现在看一下表的定义，看到每一行都正确的生成了

81
00:10:53,000 --> 00:11:00,500
并且重用类型被扩展为列声明试的类型

82
00:11:01,000 --> 00:11:06,000
现在让我给你展示一个更加复杂的例子

83
00:11:06,500 --> 00:11:15,500
这我以在SP05中介绍的EPM模型为例子

84
00:11:16,000 --> 00:11:23,000
如果你以前看过，以前有很多hdbdd文件来定义不同的表

85
00:11:23,000 --> 00:11:39,500
但是现在只有一个文件，这样的好处是一个hdbdd文件包含多个表的定义

86
00:11:40,000 --> 00:11:43,000
而我们所需要的对象都在一个文件中（更好的重用）

87
00:11:43,500 --> 00:11:54,500
它的context是EPM，包含了一些简单和复杂的重用类型

88
00:11:54,500 --> 00:12:07,000
比如开始和结束时间很多地方要用到，这里只需定义一个类型ValidityT

89
00:12:07,500 --> 00:12:08,500
在表的内部可以直接重用这个复杂类型ValidityT


90
00:12:09,000 --> 00:12:16,000
另外context也可以被嵌套使用

91
00:12:16,500 --> 00:12:22,500
这个例子EPM context就内嵌了MasterData context

92
00:12:23,000 --> 00:12:30,000
因此Addresses表就会创建为EPM.MasterData.Addresses的表

93
00:12:30,500 --> 00:12:39,550
你可以看到类型的重用是如此的简单，因为可以直接使用ValidityT作为列类型。

94
00:12:40,050 --> 00:12:48,050
因为Addresses重用了ValidityT,所以现在Addresses中就有开始和结束时间两列

95
00:12:48,550 --> 00:12:57,550
类型也有作用域范围，有些类型全局的是属于EMP context的一部分

96
00:12:58,050 --> 00:13:07,050
另外一些类型属于内部类型，比如nameT是属于MasterData context

97
00:13:07,550 --> 00:13:14,550
这里在MasterData中定义了Address, Business Partner, Employee等表结构


98
00:13:15,000 --> 00:13:26,050
这里也定于了Sales, Contact，Purchase的header和item实体。

99
00:13:26,550 --> 00:13:28,550
我想你已经大致了解了。

100
00:13:29,050 --> 00:13:37,050
激活这个hdbdd文件，回到SP6Demo数据库目录中

101
00:13:37,550 --> 00:13:51,550
首先看下Procedures,可以看到可重用的表类型

102
00:13:52,050 --> 00:14:07,050
回到上面，可以看到比如ValidityT，HistoryT被定义为可重用的表类型

103
00:14:07,500 --> 00:14:12,500
打开它们的定义，可以在下拉框里看出是声明的表类型

104
00:14:13,000 --> 00:14:18,000
这些表类型也可以被用在SQL存储过程中

105
00:14:18,000 --> 00:14:30,000
用来定义存储过程，不仅可以在存储过程中声明表类型

106
00:14:30,500 --> 00:14:48,500
在EPM中可以声明一个Procedure Context，声明所有的输入输出参数

107
00:14:49,000 --> 00:15:01,000
这样就可以在一处声明重用的表类型在分享重用，而就不用在每个存储过程中重复声明


108
00:15:01,500 --> 00:15:11,500
当你看生成的表时，你会发现它们都遵守命名规则并组织良好

109
00:15:12,000 --> 00:15:24,000
遵循规则为   命名空间::Context.表名称

110
00:15:24,500 --> 00:15:34,000
表在相同的context下被组织在一起，如Purchase, Sale，Util等

111
00:15:34,000 --> 00:15:45,000
看MasterData下的Addresses表定义，每一行都是在hdbdd中定义的

112
00:15:45,500 --> 00:15:50,500
Addresses还重用了ValidityT类型

113
00:15:51,000 --> 00:15:55,000
故在表中看到有Validity.startDate和Validity.EndDate

114
00:15:55,500 --> 00:16:05,500
在定义时，只需定义一个类型为ValidityT的列Validity

115
00:16:05,500 --> 00:16:18,000
如果新增加一个新的字段，所有使用ValidityT的表都会拥有

116
00:16:18,500 --> 00:16:29,500
重用最后会实现字段在属性（类型，注释等）在不同表之间的一致性。
